# -*- coding: utf-8 -*-
"""GARCH.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1MW8o14DA5iGXxvr9a1MLawX7okT7JyOV
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from arch import arch_model
from sklearn.metrics import mean_squared_error, mean_absolute_error
from statsmodels.tsa.stattools import adfuller

def run_model():
    file_path_bitcoin_norm = "./workspace/bitcoin_norm.csv"
    file_path_bitcoin_df = "./workspace/bitcoin_price.csv"

    # 데이터 불러오기 및 컬럼명 변경
    def load_and_rename(file_path, prefix):
        df = pd.read_csv(file_path, parse_dates=['Date'], index_col='Date')
        df = df.add_prefix(prefix + '_')
        return df

    bitcoin_norm = load_and_rename(file_path_bitcoin_df, 'bitcoin') #df_norm
    bitcoin_df = load_and_rename(file_path_bitcoin_df, 'bitcoin_r') #not normalized #df

    # 로그 수익률 및 변동성 계산
    bitcoin_df['bitcoin_log_returns'] = np.log(bitcoin_df['bitcoin_r_Close'] / bitcoin_df['bitcoin_r_Close'].shift(-1))
    bitcoin_norm['bitcoin_volatility'] = bitcoin_df['bitcoin_log_returns'].rolling(window=2).std() * np.sqrt(365)
    bitcoin_norm['bitcoin_volatility'] = bitcoin_norm['bitcoin_volatility'] ** (0.3)

    # 데이터 분할
    # Sort the DataFrame by its index
    bitcoin_norm.sort_index(inplace=True)

    train = bitcoin_norm['2021-02-01':'2023-09-05']
    validation = bitcoin_norm['2023-09-06':'2024-01-01']
    test = bitcoin_norm['2024-01-02':'2024-04-28']

    # 시계열 데이터 시각화
    train['bitcoin_volatility'].plot(figsize=(10, 6), label='Train')
    validation['bitcoin_volatility'].plot(label='Validation')
    test['bitcoin_volatility'].plot(label='Test')
    plt.title('Bitcoin Volatility Time Series')
    plt.legend()
    plt.show()

    model = arch_model(train['bitcoin_volatility'], vol='Garch', p=1, q=1)
    # 모델 피팅
    model_fit = model.fit(disp='off')
    # 결과 출력
    print(model_fit.summary())

    # 최종 모델 피팅 (Train + Validation 데이터)
    am_final = arch_model(pd.concat([train['bitcoin_volatility'], validation['bitcoin_volatility']]), vol='Garch', p=1, q=1)
    res_final = am_final.fit(disp='off')
    print(res_final.summary())

    # AIC를 기준으로 최적의 p, q 찾기
    def find_best_garch_params(train_data, validation_data, max_p=5, max_q=5):
        best_aic = float('inf')
        best_p = 0
        best_q = 0
        best_model = None

        for p in range(1, max_p + 1):
            for q in range(1, max_q + 1):
                try:
                    model = arch_model(train_data, vol='Garch', p=p, q=q)
                    res = model.fit(disp='off')
                    # 검증 데이터셋에 대한 예측 수행
                    validation_forecast = res.forecast(horizon=len(validation_data))
                    validation_predicted_volatility = validation_forecast.variance.values[-1, :]
                    # AIC 기준으로 최적 모델 선택
                    if res.aic < best_aic:
                        best_aic = res.aic
                        best_p = p
                        best_q = q
                        best_model = res
                except:
                    continue

        return best_p, best_q, best_model

    # Train and Validation 데이터 결합
    train_validation = pd.concat([train['bitcoin_volatility'], validation['bitcoin_volatility']])

    # 최적의 p, q 찾기
    best_p, best_q, best_model = find_best_garch_params(train['bitcoin_volatility'], validation['bitcoin_volatility'])

    print(f'Best p: {best_p}, Best q: {best_q}')
    print(best_model.summary())

    # test 데이터 예측 수행
    forecasts = best_model.forecast(horizon=len(test))

    # 예측 결과 추출 (conditional volatilities)
    predicted_volatility = forecasts.variance.values[-1, :]

    # 예측 결과를 DataFrame으로 변환
    predicted_volatility_df = pd.DataFrame(predicted_volatility, index=test.index, columns=['predicted_volatility'])

    print(predicted_volatility_df)

    # 10/3 제곱 수행
    actual_volatility_powered = np.power(test['bitcoin_volatility'].values, 10/3)
    predicted_volatility_powered = np.power(predicted_volatility_df['predicted_volatility'].values, 10/3)

    # RMSE 계산
    rmse = np.sqrt(mean_squared_error(actual_volatility_powered, predicted_volatility_powered))

    # MAE 계산
    mae = mean_absolute_error(actual_volatility_powered, predicted_volatility_powered)

    # MAPE 계산
    mape = np.mean(np.abs((actual_volatility_powered - predicted_volatility_powered) / actual_volatility_powered)) * 100

    print(f'RMSE: {rmse}')
    print(f'MAE: {mae}')
    print(f'MAPE: {mape}%')

    # 시각화
    plt.figure(figsize=(12, 6))
    plt.plot(test.index, actual_volatility_powered, label='Actual Volatility (Powered)', color='blue')
    plt.plot(test.index, predicted_volatility_powered, label='Predicted Volatility (Powered)', color='red', linestyle='--')
    plt.title('Actual vs Predicted Volatility (Powered)')
    plt.xlabel('Date')
    plt.ylabel('Volatility (Powered)')
    plt.legend()
    plt.show()

if __name__ == "__main__":
    run_model()
