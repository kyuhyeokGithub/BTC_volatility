# -*- coding: utf-8 -*-
"""GradientBoostingMachine.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/13jdGoaW57DLQvzBOG5p-e7xdQQCP-6iJ
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from sklearn.ensemble import GradientBoostingRegressor
from sklearn.preprocessing import StandardScaler
from sklearn.metrics import mean_squared_error, mean_absolute_error

def run_model():
    # 파일 경로 설정
    file_path_news_df = './workspace/news_norm.csv'
    file_path_usdc_df = './workspace/usdc_norm.csv'
    file_path_bitcoin_norm = "./workspace/bitcoin_norm.csv"
    file_path_ether_df = './workspace/ether_norm.csv'
    file_path_bitcoin_df = "./workspace/bitcoin_price.csv"

    # 데이터 불러오기 및 컬럼명 변경
    def load_and_rename(file_path, prefix):
        df = pd.read_csv(file_path, parse_dates=['Date'], index_col='Date')
        df = df.add_prefix(prefix + '_')
        return df

    news_df = load_and_rename(file_path_news_df, 'news')
    usdc_df = load_and_rename(file_path_usdc_df, 'usdc')
    bitcoin_norm = load_and_rename(file_path_bitcoin_df, 'bitcoin') #df_norm
    ether_df = load_and_rename(file_path_ether_df, 'ether')
    bitcoin_df = load_and_rename(file_path_bitcoin_df, 'bitcoin_r') #not normalized #df

    # 로그 수익률 및 변동성 계산
    bitcoin_df['bitcoin_log_returns'] = np.log(bitcoin_df['bitcoin_r_Close'] / bitcoin_df['bitcoin_r_Close'].shift(-1))
    bitcoin_norm['bitcoin_volatility'] = bitcoin_df['bitcoin_log_returns'].rolling(window=2).std() * np.sqrt(365)
    bitcoin_norm['bitcoin_volatility'] = bitcoin_norm['bitcoin_volatility'] ** (0.3)

    # 타겟 변수 설정
    merged_df = pd.concat([news_df, usdc_df, bitcoin_norm, ether_df], axis=1).dropna()
    merged_df['bitcoin_volatility'] = bitcoin_norm['bitcoin_volatility']

    # DatetimeIndex 정렬
    merged_df = merged_df.sort_index()

    # 데이터 분할
    train = merged_df['2021-02-01':'2023-09-05']
    validation = merged_df['2023-09-06':'2024-01-01']
    test = merged_df['2024-01-02':'2024-04-28']

    # 독립 변수와 종속 변수 분리
    X_train = train.drop(columns=['bitcoin_volatility'])
    y_train = train['bitcoin_volatility']
    X_validation = validation.drop(columns=['bitcoin_volatility'])
    y_validation = validation['bitcoin_volatility']
    X_test = test.drop(columns=['bitcoin_volatility'])
    y_test = test['bitcoin_volatility']

    # 데이터 스케일링
    scaler = StandardScaler()
    X_train_scaled = scaler.fit_transform(X_train)
    X_validation_scaled = scaler.transform(X_validation)
    X_test_scaled = scaler.transform(X_test)

    # Gradient Boosting Machine 모델 구축
    gbm_model = GradientBoostingRegressor(n_estimators=100, learning_rate=0.1, max_depth=3, random_state=42)
    gbm_model.fit(X_train_scaled, y_train)

    # 검증 데이터 예측
    validation_predict = gbm_model.predict(X_validation_scaled)

    # 예측값 시각화 (Validation)
    plt.figure(figsize=(10, 6))
    plt.plot(validation.index, y_validation, label='Actual Volatility')
    plt.plot(validation.index, validation_predict, label='Predicted Volatility')
    plt.title('Bitcoin Volatility Forecast vs Actuals (Validation)')
    plt.legend()
    plt.show()

    # 검증 데이터 예측 성능 평가
    validation_rmse = np.sqrt(mean_squared_error(y_validation, validation_predict))
    validation_mae = mean_absolute_error(y_validation, validation_predict)
    validation_mape = np.mean(np.abs((y_validation - validation_predict) / y_validation)) * 100
    print(f'Validation RMSE: {validation_rmse}')
    print(f'Validation MAE: {validation_mae}')
    print(f'Validation MAPE: {validation_mape}%')

    # 전체 테스트 데이터 예측
    test_predict_all_gbm = gbm_model.predict(X_test_scaled)

    # 새로운 손실값을 계산하고 성능 평가 지표 재계산
    def calculate_new_metrics(actual, predicted):
        actual_new = actual ** (10/3)
        predicted_new = predicted ** (10/3)
        new_rmse = np.sqrt(mean_squared_error(actual_new, predicted_new))
        new_mae = mean_absolute_error(actual_new, predicted_new)
        new_mape = np.mean(np.abs((actual_new - predicted_new) / actual_new)) * 100
        return new_rmse, new_mae, new_mape

    # 테스트 데이터에서 새로운 성능 평가
    test_new_rmse, test_new_mae, test_new_mape = calculate_new_metrics(y_test, test_predict_all_gbm)

    print(f'New Test RMSE: {test_new_rmse}')
    print(f'New Test MAE: {test_new_mae}')
    print(f'New Test MAPE: {test_new_mape}%')

    # 새로운 예측값 시각화 (Test, 전체 기간)
    plt.figure(figsize=(10, 6))
    plt.plot(test.index, y_test ** (10/3), label='Actual Test Volatility (10/3)', color='black')
    plt.plot(test.index, test_predict_all_gbm ** (10/3), label='Predicted Test Volatility (10/3)', color='red', linestyle='--')
    plt.title('Bitcoin Volatility Forecast vs Actuals (Test)')
    plt.xlabel('Date')
    plt.ylabel('Volatility (10/3)')
    plt.legend()
    plt.show()

if __name__ == "__main__":
    run_model()
